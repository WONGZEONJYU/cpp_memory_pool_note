# 实战基于 c++17、多线程、内存池批量文件加解密程序

# 1.基本技术

* 用到多线程技术 , 详见多线程课程
* 用到加解密技术 详见 `openssl` 课程
* 用到 **$\color{red}{责任链模式}$**
* 用到智能指针、 内存池、 线程相关技术  

# 2. 类图

<img src="assets/image-20231024175238365.png" alt="image-20231024175238365" />

# 3. 类作用

* `IOStream` (线程基类) :  责任链模式 , 多线程数据传递 , 内存池注入和空间管理
* `XReadTask` (文件读取类) : 继承 `IOStream` 读取文件 , 发送给下一个责任链 , 需要告知下一个责任链任务结束
* `XWriteTask` (文件写入类) : 继承 `IOStream` , 写入文件现场, 接收 `XEncryptTask` 类 发送的加解密数据
* `XCryptTask` (加解密线程类) : 继承 `IOStream` , 关联 `XCrypt` , 加解密处理线程
* `XCrypt` (加解密类) : 组合 `XCryptTask XWriteTask `
* `XFileCrypt` (操作组合类) 

# 4. 实验

[[工程参考链接]]()

## 4.1 工程配置

<img src="assets/image-20231026115256724.png" alt="image-20231026115256724" /> 

 <img src="assets/image-20231026115827453.png" alt="image-20231026115827453" /> 

<img src="assets/image-20231026115922047.png" alt="image-20231026115922047" /> 

<img src="assets/image-20231026141035452.png" alt="image-20231026141035452" /> 

## 4.2 `XCrypt` 类创建

### 4.2.1 `xcrypt.h`

>```c++
>#ifndef XCRYPT_H_
>#define XCRYPT_H_
>
>#include <string>
>#include <openssl/des.h>
>
>class XCrypt
>{
>public:
>
>	/// <summary>
>	/// 初始化密钥 , DES加密算法 密钥最多8bit 多余丢弃不足补0
>	/// </summary>
>	/// <param name="password"></param>
>	/// <returns>ture or false</returns>
>
>	bool Init(std::string password);
>
>	 /// <summary>
>	 /// 加密数据,结尾填充补充的大小 加密数据大小如果不是 8, 16的倍数
>	 /// </summary>
>	 /// <param name="in_data">输入数据</param>
>	 /// <param name="insize">输入数据大小</param>
>	 /// <param name="out_data">输出数据</param>
>	 /// <param name="is_end">是否到加密结尾</param>
>	 /// <returns>0 or size 返回加密后数据大小, 有可能大于输入 , 添加补充</returns>
>
>	size_t Encrypt(const char* in_data,size_t insize,
>		char* out_data, bool is_end = false) ;
>
>	 /// <summary>
>	 /// 解密数据,结尾去掉填充大小
>	 /// </summary>
>	 /// <param name="in_data">输入数据</param>
>	 /// <param name="insize">输入数据大小</param>
>	 /// <param name="out_data">输出数据</param>
>	 /// <param name="is_end">是否到加密结尾</param>
>	 /// <returns>-1 or size 返回解密后数据大小 , 有可能小于输入 , 去掉补充</returns>
>
>	size_t Decrypt(const char* in_data, size_t insize,
>		char* out_data,bool is_end = false);
>
>private:
>	/*存储密钥*/
>	DES_key_schedule key_sch_;
>};
>
>#endif // 
>```

### 4.2.2 `xcrypt.cpp`

#### 4.2.2.1 初始化和加密 API 实现

> ```c++
> #include "xcrypt.h"
> 
> /*初始化密钥 , DES加密算法 密钥最多8bit 多余丢弃不足补0*/
> bool XCrypt::Init(std::string password)
> {
>     const_DES_cblock key{}; /*不足补0,初始化就置0*/
>     auto key_size{ password.size()};
> 
>     if (key_size > sizeof(key)){ /*多余丢弃*/
>         key_size = sizeof(key);
>     }
>     
>     memcpy(key, password.c_str(), key_size);
>     (void)DES_set_key(&key,&key_sch_);
>     return true;
> }
> 
> /// <summary>
> /// 加密数据,结尾填充补充的大小 加密数据大小如果不是 8, 16的倍数
> /// </summary>
> /// <param name="in_data">输入数据</param>
> /// <param name="insize">输入数据大小</param>
> /// <param name="out_data">输出数据</param>
> /// <param name="is_end">是否到加密结尾</param>
> /// <returns>0 or size 返回加密后数据大小, 有可能大于输入 , 添加补充</returns>
> /// 
> /// 
> size_t XCrypt::Encrypt(const char* in_data, const size_t insize, char* out_data, bool is_end)
> {
>     if ((!in_data) || (!out_data) || (insize <= 0)) {
>         return -1;
>     }
> 
>     const auto block_size{ sizeof(const_DES_cblock) }, over{ insize % block_size },
>         padding{ block_size - over };
> 
>     size_t write_size{}, data_size{};
> 
>     for (size_t i{}; i < insize; i+= block_size){
> 
>         const_DES_cblock in{}; /*输入(未加密数据)*/
>         DES_cblock out{};/*输出(加密后数据)*/
> 
>         const auto temp_v{ insize - i };
> 
>         data_size = (temp_v < block_size) ? temp_v : block_size;
> 
>         memcpy(in, in_data + write_size, data_size);
> 
>         /*填充 补充的数据大小 @@@@@@@1 @@@55555 @@@@@@@@88888888*/
>         const auto r{ is_end && ((i + block_size) >= insize) };
> 
>         if (r){
>             //@@@@@@@@8888888
>             if (padding == block_size) { /*补充多8个字节*/
>                 DES_ecb_encrypt(&in, &out, &key_sch_, DES_ENCRYPT);
>                 memcpy(out_data + write_size, &out, block_size);
>                 write_size += block_size;
>                 memset(in, padding, sizeof(in)); //填充8
>             }else{ //@@@@@@@1   @@@55555
>                 memset(in + over, padding, padding);
>             }
>         }
> 
>         DES_ecb_encrypt(&in,&out,&key_sch_,DES_ENCRYPT);
>         memcpy(out_data + write_size, &out, block_size);
>         write_size += block_size;
>     }
> 
>     return write_size;
> }
> 
> ```

#### 4.2.2.2 加密测试

> ```c++
> #include <iostream>
> #include "xcrypt.h"
> 
> using namespace std;
> 
> int main(int argc, char* argv[])
> {
> 	XCrypt crypt;
> 	crypt.Init("12345678");
> 
> 	char out[1024]{};
> 
> 	auto en_size{ crypt.Encrypt("abcdefgh",24, out,true) };/*8的倍数*/
> 	cout << "en_size = " << en_size << "\nAfter encryption : " << 
> 			out << "\n";
> 
> 	en_size = crypt.Encrypt("abcdefg", 9, out, true);/*非8的倍数*/
> 	cout << "en_size = " << en_size << "\nAfter encryption : " <<
> 		out << "\n";
> 
> 	(void)getchar();
> 	return 0;
> }
> 
> ```

<img src="assets/image-20231027171829299.png" alt="image-20231027171829299" />   

#### 4.2.2.3 解密实现

>```c++
>/// <summary>
>/// 解密数据,结尾去掉填充大小
>/// </summary>
>/// <param name="in_data">输入数据</param>
>/// <param name="insize">输入数据大小</param>
>/// <param name="out_data">输出数据</param>
>/// <param name="is_end">是否到加密结尾</param>
>/// <returns>-1 or size 返回解密后数据大小 , 有可能小于输入 , 去掉补充</returns>
>
>size_t XCrypt::Decrypt(const char* in_data, const size_t insize, char* out_data, const bool is_end)
>{
>    if ((!in_data) || (!out_data) || (insize <= 0)) {
>        return 0;
>    }
>
>    const auto block_size{ sizeof(const_DES_cblock) }, over{ insize % block_size },
>        padding{ block_size - over };
>
>    size_t write_size{}, data_size{};
>
>    for (size_t i {}; i < insize; i+= block_size) {
>
>        const_DES_cblock in{}; /*输入(已加密数据)*/
>        DES_cblock out{};/*输出(解密后数据)*/
>
>        memcpy(&in, in_data + write_size, block_size);
>        DES_ecb_encrypt(&in, &out, &key_sch_, DES_DECRYPT); /*解密*/
>
>        data_size = block_size;/*默认情况data_size == block_size*/
>
>        /*处理结尾处*/
>
>        /*如果数据长度不是8的倍数，那么最后一块数据不足8个字节的位置都会被填充为剩余的长度大小这个数值
>        * 比如 @@@55555 , 5是从第三个位置开始填充,到结尾也是5,所以out[7] == 5
>        */
>
>        const auto is_ { is_end && ((insize - i) <= block_size)};
>
>        if (is_){
>
>            data_size = block_size - out[7]; 
>            /*通过最后一个元素的值可以计算出还需拷贝多少个数据*/
>
>            if (!data_size){ /*如果是8的倍数,data_size == 0*/
>                break;
>            }else if(data_size < 0){ /*异常情况*/
>                cerr << "Decrypt failed!padding size error\n";
>                break;
>            }else { /*正常情况*/
>
>            }
>        }
>
>        memcpy(out_data + write_size, &out, data_size);
>        write_size += block_size;
>    }
>
>    return write_size;
>}
>```

#### 4.2.2.3 解密测试

>```c++
>#include <iostream>
>#include "xcrypt.h"
>
>using namespace std;
>
>int main(int argc, char* argv[])
>{
>	XCrypt crypt;
>	crypt.Init("12345678");
>
>#if 1
>	{
>		cout << "====================1 begin======================\n";
>
>		char out[1024]{};
>		auto en_size{ crypt.Encrypt("abcdefghijklmn",24, out,true) };/*8的倍数*/
>		cout << "en_size = " << en_size << 
>			"\nAfter encryption : " << out << "\n";
>
>		char de_out[1024]{};
>		auto de_size{ crypt.Decrypt(out, en_size,de_out, true) };
>		cout << "de_size = " << de_size <<
>				"\nde_out : " << de_out << "\n";
>
>		cout << "=====================1 end=======================\n\n";
>	}
>
>	{
>		cout << "====================2 begin======================\n";
>		char out[1024]{};
>		auto en_size{ crypt.Encrypt("abcdefgh",8, out,true) };
>		cout << "en_size = " << en_size << "\nAfter encryption : " <<
>		out << "\n";
>
>		char de_out[1024]{};
>		auto de_size{ crypt.Decrypt(out, en_size,de_out, true) };
>		cout << "de_size = " << de_size <<
>			"\nde_out : " << de_out << "\n";
>		cout << "=====================2 end=======================\n\n";
>	}
>
>	{
>		cout << "====================3 begin======================\n";
>		char out[1024]{};
>		auto en_size = crypt.Encrypt("abcdefghi", 9, out, true);
>		cout << "en_size = " << en_size << 
>				"\nAfter encryption : " << out << "\n";
>
>		char de_out[1024]{};
>		auto de_size{ crypt.Decrypt(out, en_size,de_out, true) };
>		cout << "de_size = " << de_size <<
>			"\nde_out : " << de_out << "\n";
>		cout << "=====================3 end=======================\n\n";
>	}
>#endif
>	(void)getchar();
>	return 0;
>}
>
>```

<img src="assets/image-20231028102015301.png" alt="image-20231028102015301" /> 

## 4.3 `XIOStream` 类创建

### 4.3.1 `xiostream.h`

>```c++
>#ifndef XIOSTREAM_H_
>#define XIOSTREAM_H_
>
>#include <thread>
>
>class XIOStream
>{
>	XIOStream(const XIOStream&) = delete;
>	XIOStream(XIOStream&&) = delete;
>	XIOStream& operator=(const XIOStream&) = delete;
>	XIOStream& operator=(XIOStream&&) = delete;
>
>public:
>	explicit XIOStream() = default;
>	/// <summary>
>	/// 线程启动
>	/// </summary>
>	void Start();
>
>	/// <summary>
>	/// 等待线程退出
>	/// </summary>
>	void Wait();
>
>	/// <summary>
>	/// 线程退出,需要用Wait等待
>	/// </summary>
>	void Stop();
>
>protected:
>	/// <summary>
>	/// 线程入口函数
>	/// </summary>
>	virtual void Main() {}
>
>	/// <summary>
>	/// 
>	/// </summary>
>	/// <returns></returns>
>	constexpr bool is_exit() const noexcept { return is_exit_; };
>
>	/// <summary>
>	/// 保存文件大小
>	/// </summary>
>	/// <param name=""></param>
>	void Ass_data_byte(uint64_t);
>
>	/// <summary>
>	/// 获取文件大小
>	/// </summary>
>	/// <returns></returns>
>	uint64_t xs_data_byte() const;
>
>private:
>	std::thread th_;
>	bool is_exit_{};
>	uint64_t data_byte_{};
>};
>
>#endif
>
>```

### 4.3.2 `xiostream.cpp`

>```c++
>#include "xiostream.h"
>
>using namespace std;
>
>/// <summary>
>/// 线程启动
>/// </summary>
>void XIOStream::Start() {
>	th_ = thread(&XIOStream::Main, this);
>}
>
>/// <summary>
>/// 等待线程退出
>/// </summary>
>void XIOStream::Wait() {
>	if (th_.joinable()) {
>		th_.join();
>	}
>}
>/// <summary>
>/// 线程退出,需要用Wait等待
>/// </summary>
>void XIOStream::Stop() {
>	is_exit_ = true;
>}
>/// <summary>
>/// 保存文件大小
>/// </summary>
>/// <param name=""></param>
>void XIOStream::Ass_data_byte(const uint64_t n) {
>	data_byte_ = n;
>}
>/// <summary>
>/// 获取文件大小
>/// </summary>
>/// <returns></returns>
>uint64_t XIOStream::xs_data_byte() const {
>	return data_byte_;
>}
>
>```

## 4.4 `XReadTask` 类创建

### 4.4.1 `XReadTask.h`

>```c++
>#ifndef XREADTASK_H_
>#define XREADTASK_H_
>
>#include "xiostream.h"
>#include <string>
>#include <fstream>
>
>class XReadTask : public XIOStream
>{
>public:
>	/// <summary>
>	/// 初始化读取线程,获取文件大小
>	/// </summary>
>	/// <param name="filename"></param>
>	/// <returns></returns>
>	bool Init(std::string filename);
>
>private:
>	/// <summary>
>	/// 线程入口函数
>	/// </summary>
>	void Main() override;
>	std::ifstream ifs_;
>};
>
>#endif
>```

### 4.4.2 `XReadTask.cpp`

>```c++
>#include "xreadtask.h"
>#include <iostream>
>#include <thread>
>
>using namespace std;
>using namespace chrono;
>using namespace this_thread;
>
>/// <summary>
>/// 初始化读取线程,获取文件大小
>/// </summary>
>/// <param name="filename"></param>
>/// <returns></returns>
>bool XReadTask::Init(string filename)
>{
>	if (filename.empty()){
>		return false;
>	}
>	
>	ifs_.open(filename, ios::binary);
>
>	if (!ifs_){
>		cerr << "open file " << filename << " failed!\n";
>		return false;
>	}
>
>	cout << "open succcess!\n";
>
>	ifs_.seekg(0, ios::end);/*Move to end of file*/
>
>	Ass_data_byte(ifs_.tellg());
>
>	ifs_.seekg(0, ios::beg); /*Move to beginning of file*/
>
>	cout << " file size = " << xs_data_byte() << "\n";
>
>	return true;
>}
>
>void XReadTask::Main()
>{
>	cout << "begin " << __FUNCTION__ << "\n";
>	while (!is_exit()){
>		if (ifs_.eof()){
>			break;
>		}
>
>		char buf[1024 * 10]{};
>		ifs_.read(buf, sizeof(buf));
>		cout << "[" << ifs_.gcount() << "] " << flush;
>
>	}
>	cout << "\nend " << __FUNCTION__ << "\n";
>}
>
>```

### 4.4.3 文件读取测试

>```c++
>#include <iostream>
>#include "xcrypt.h"
>#include "xreadtask.h"
>
>using namespace std;
>
>int main(int argc, char* argv[])
>{	
>    XReadTask rt;
>	rt.Init("../../bin/x86/img/test.png");
>	rt.Start();
>	rt.Wait();
>
>	(void)getchar();
>	return 0;
>}
>
>```

<img src="assets/image-20231030152626746.png" alt="image-20231030152626746" /> 

## 4.5 `XData` 类创建

### 4.5.1 `XData.h`

>```c++
>#ifndef XDATA_H
>#define XDATA_H
>
>#include <memory>
>#include <memory_resource>
>
>class XData final
>{
>	explicit XData() = default;
>	XData(const XData& ) = delete;
>	XData(XData&&) = delete;
>	XData& operator=(const XData&) = delete;
>	XData& operator=(XData&&) = delete;
>	
>public:
>	using _sp_mrs_type = std::shared_ptr<std::pmr::memory_resource>;
>	using _sp_xdata_type = std::shared_ptr<XData>;
>	/// <summary>
>	/// 创建空间
>	/// </summary>
>	/// <param name="">占用内存字节数</param>
>	/// <returns></returns>
>	void* New(uint64_t);
>
>	/// <summary>
>	/// 设置实际数据字节数
>	/// </summary>
>	/// <param name=""></param>
>	void set_size(const uint64_t s) {
>		size_ = s;
>	}
>
>	/// <summary>
>	/// 创建XData智能指针对象
>	/// </summary>
>	/// <param name="pool"></param>
>	/// <returns></returns>
>	static _sp_xdata_type Make(const _sp_mrs_type& );
>
>	~XData();
>
>private:
>	void* data_{};
>	uint64_t size_{};/*数据字节数*/
>	uint64_t mem_size_{};/*占用空间字节数*/
>	_sp_mrs_type mem_pool_;
>};
>
>#endif
>
>```

### 4.5.2 `XData.cpp`

>```c++
>#include "xdata.h"
>#include <iostream>
>
>using namespace std;
>using namespace pmr;
>
>/// <summary>
>/// 创建XData智能指针对象
>/// </summary>
>/// <param name="pool"></param>
>/// <returns></returns>
>XData::_sp_xdata_type XData::Make(const _sp_mrs_type& pool)
>{
>	_sp_xdata_type ptr{ new XData() };
>	ptr->mem_pool_ = pool;
>	return ptr;
>}
>
>/// <summary>
>/// 创建空间
>/// </summary>
>/// <param name="">占用内存字节数</param>
>/// <returns></returns>
>void* XData::New(const uint64_t mem_size)
>{
>	if (mem_size <= 0){
>		cerr << __FUNCTION__ << " failed! mem_size <=0\n";
>		return {};
>	}
>
>	if (!mem_pool_){
>		cerr << __FUNCTION__ << " failed! mem_pool Uninitialized\n";
>		return {};
>	}
>
>	data_ = mem_pool_->allocate(mem_size);
>	mem_size_ = mem_size_;
>	size_ = mem_size_;
>	return data_;
>}
>
>XData::~XData()
>{
>	const auto is_{ ((!data_) || (!mem_pool_)) };
>
>	if (is_){
>		return;
>	}
>
>	mem_pool_->deallocate(data_, mem_size_);
>	data_ = nullptr;
>	size_ = 0;
>}
>
>```



